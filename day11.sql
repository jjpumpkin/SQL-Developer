/* 뷰 view 338p
   하나 이상의 테이블을 연결해 마치 테이블인 것 처럼 사용하는 객체
   실제 데이터는 뷰를 구성하는 테이블에 담겨 있지만 테이블 처럼 사용가능
   사용 목적 : 1.자주 사용하는 SQL문을 매번 작성할 필요 없이 뷰로 생성하여 사용가능
              2.데이터 보안 측면(원천 테이블을 감출 수 있음)
    뷰 특징: (1) 단순 뷰 (테이블 1개)
            -그룹함수 사용불가
            -distinct 사용불가
            -insert/update/delete 사용가능
            (2) 복합 뷰(여러개 테이블)
               - 그룹함수 사용가능
               - distinct 사용가능
               - insert/update/delete 불가능
*/
CREATE OR REPLACE VIEW emp_dep AS  -- 만들수 있는 권한이 없어 오류뜸
SELECT a.employee_id
      ,a.emp_name
      ,b.department_id
      ,b.department_name
FROM employees a, departments b
WHERE a.department_id = b.department_id;

-- SYSYEM 계정에서 JAVA 계정에 뷰를 생성할 수 있는 권한 부여
GRANT CREATE VIEW TO java;
SELECT *
FROM EMP_DEP;


-- java 계정에서 emp_dep view를 조회할 수 있는 권한을 study계정에게 부여함
GRANT SELECT ON emp_dep TO study;-- 스터디 계정으로 조회 가능


-- study 계정에서 조회
SELECT*
FROM java.emp_dep;  --뷰는 자바인데 자바계정에서 스터디계정에게 권한을 부여 스키마 붙힘

--view 삭제
DROP view emp_dep;

/*  동의어(synonym) 354p
    시노님은 동의어란 뜻으로 객체 각자의 고유한 이름에 대한 동의어를 만드는것
    public synonym 특정 사용자만 접근
    publisynonym은 dba 권한이 있는 사용자만 가능 (생성 삭제)
    사용 목적: 1.보안측면 계정명(id) , 테이블명과 같은 중요한 정보를 숨기기 위해 별칭을 만듬
              2. 개발 편의성 실제 테이블의 정보가 변경되어도 별칭으로 사용했다면 코드수정 안해도됨.
*/

--system 계정에서 시노님 생성 권한 부여
GRANT CREATE SYNONYM TO member;
-- member 계정에서 member 테이블
-- default private synonym
CREATE OR REPLACE SYNONYM mem FOR member; -- member 테이블을 mem 으로
-- java 계정에서 mem 조회할 수 있는 권한 부여
GRANT SELECT ON mem TO java;
SELECT *
FROM member.mem;
-- system 계정에서 public synonym 생성 (member 계정의 member 테이블)
CREATE OR REPLACE PUBLIC SYNONYM mem2 FOR member.member;
GRANT SELECT ON mem2 TO study; --system 계정에서 권한 스터디계정에 권한부여
SELECT *
FROM mem2;

--권한 해제
--REVOKE 권한 FROM 계정명
--public synonym 삭제는 DBA권한이 있어야함.
DROP PUBLIC SYNONYM mem2;

CREATE SEQUENCE my_seq2

INCREMENT BY 10 --증강숫자
START WITH 1000    --시작숫자
MINVALUE   1    --최소값
MAXVALUE   999999999 ;
--최대값
--NOCYCLE         --최대나 최소에 도달하면 생성중지 (cycle은 다시 돌아감)
--NOCACHE;        --메모리에 최대 시퀀스 값을 할당 하지말지 (cache 할당함)
SELECT my_seq2.NEXTVAL
FROM dual;
CREATE TABLE ex11 (
      dep_seq NUMBER PRIMARY KEY
      ,dt    DATE DEFAULT SYSDATE
      );
      INSERT INTO exll (dep_seq)VALUES (my_seq2.NEXTVAL);
       INSERT INTO exll (dep_seq)VALUES ((SELECT MAX(NVL(my_seq,0)) +10
                                           FROM ex11));
      SELECT * FROM ex11;
      
SELECT MAX(NVL(dep_seq,0)) +10
FROM ex11;


--oracle 12 버전 부터 사용가능
-- IDENTITY (테이블 생성시 사용가능)
CREATE TABLE ex11_1(
   seq NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY
  ,title VARCHAR2(100)
);

INSERT INTO ex11_1 (title) VALUES ('ha ha');
SELECT *
FROM ex11_1;
CREATE TABLE ex11_2 (
   seq NUMBER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 100
        INCREMENT BY 10
        MINVALUE 10
        MAXVALUE 1000000
    ) PRIMARY KEY
    , title VARCHAR2(100)
);
INSERT INTO ex11_2(title) VALUES('하이');
SELECT * FROM ex11_2;

-- 세미조인 ?
-- EXISTS 서브쿼리에서 결과 하나라도 존재하면 TRUE, 없으면 FALSE를 반환
-- 서브쿼리의 결과가 존재하는지 여부를 확인하는데 사용됨.
-- 수강이력이 있는(존재하는) 학생조회
SELECT *
FROM 학생 a
WHERE EXISTS (SELECT 2
              FROM 수강내역
              WHERE 학번 =a.학번);  --수강내역에 학번을 학생a에서 참고 
                                   --위에 select 별은 아무숫자 넣어도됨
                                --in같은경우에는 값이 중요한데 exists는 상관없음
                                
/* MERGE 
   UPDATE or DELETE 와 INSERT 를 한번에 처리할 수 있는 SQL문

*/
-- '과목' 테이블에 머신러닝 과목이 있으면 학점을 3으로 업데이트
--                             없으면 INSERT('머신러닝',학점:2)
SELECT *
FROM 과목;


MERGE INTO 과목 s    --대상테이블
   USING DUAL       --조건테이블 (dual은 대상테이블 조건으로 할때)
   ON (s.과목이름 = '머신러닝')  --matched 조건
   WHEN MATCHED THEN
   UPDATE SET s.학점 = 3
   WHEN NOT MATCHED THEN
   INSERT (과목번호, 과목이름, 학점)
   VALUES ((SELECT MAX(과목번호) +1
          FROM 과목),'머신러닝',2);
          

